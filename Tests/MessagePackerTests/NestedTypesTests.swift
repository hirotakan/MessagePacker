//
//  NestedTypesTests.swift
//  MessagePackerTests
//
//  Created by Hirotaka Nishiyama on 2023/01/28.
//  Copyright © 2023年 hiro. All rights reserved.
//

import XCTest
@testable import MessagePacker

class NestedTypesTests: XCTestCase {
    let encoder = MessagePackEncoder()
    let decoder = MessagePackDecoder()

    func testNestedTypeEncodingAsFlattened_encode() {
        let input = NestedTypeEncodingAsFlattened(
            outerTypeProperty: "outerTypeValue",
            innerType: .init(innerTypeProperty: "innerTypeValue")
        )
        let output = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testNestedTypeEncodingAsFlattened_decode() {
        let input = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = NestedTypeEncodingAsFlattened(
            outerTypeProperty: "outerTypeValue",
            innerType: .init(innerTypeProperty: "innerTypeValue")
        )
        XCTAssertEqual(try decoder.decode(NestedTypeEncodingAsFlattened.self, from: input), output)
    }

    func testNestedTypeEncodingAsFlattenedUnkeyed_encode() {
        let input = NestedTypeEncodingAsFlattenedUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerType: .init(innerTypeProperty: "innerTypeValue")
        )
        let output = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testNestedTypeEncodingAsFlattenedUnkeyed_decode() {
        let input = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = NestedTypeEncodingAsFlattenedUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerType: .init(innerTypeProperty: "innerTypeValue")
        )
        XCTAssertEqual(try decoder.decode(NestedTypeEncodingAsFlattenedUnkeyed.self, from: input), output)
    }

    func testFlattenedTypeEncodingAsNested_encode() {
        let input = FlattenedTypeEncodingAsNested(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        let output = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xa9, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x81, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testFlattenedTypeEncodingAsNested_decode() {
        let input = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xa9, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x81, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = FlattenedTypeEncodingAsNested(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        XCTAssertEqual(try decoder.decode(FlattenedTypeEncodingAsNested.self, from: input), output)
    }

    func testFlattenedTypeEncodingAsNestedUnkeyed_encode() {
        let input = FlattenedTypeEncodingAsNestedUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        let output = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x91, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testFlattenedTypeEncodingAsNestedUnkeyed_decode() {
        let input = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x91, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = FlattenedTypeEncodingAsNestedUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        XCTAssertEqual(try decoder.decode(FlattenedTypeEncodingAsNestedUnkeyed.self, from: input), output)
    }

    func testFlattenedTypeEncodingAsNestedWithInnerMessageUnkeyed_encode() {
        let input = FlattenedTypeEncodingAsNestedWithInnerMessageUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        let output = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xa9, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x91, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testFlattenedTypeEncodingAsNestedWithInnerMessageUnkeyed_decode() {
        let input = Data([0x82, 0xb1, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0xa9, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x91, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = FlattenedTypeEncodingAsNestedWithInnerMessageUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        XCTAssertEqual(try decoder.decode(FlattenedTypeEncodingAsNestedWithInnerMessageUnkeyed.self, from: input), output)
    }

    func testFlattenedTypeEncodingAsNestedWithOuterMessageUnkeyed_encode() {
        let input = FlattenedTypeEncodingAsNestedWithOuterMessageUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        let output = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x81, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        XCTAssertEqual(try encoder.encode(input), output)
    }

    func testFlattenedTypeEncodingAsNestedWithOuterMessageUnkeyed_decode() {
        let input = Data([0x92, 0xae, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x81, 0xb1, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0xae, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65])
        let output = FlattenedTypeEncodingAsNestedWithOuterMessageUnkeyed(
            outerTypeProperty: "outerTypeValue",
            innerTypeProperty: "innerTypeValue"
        )
        XCTAssertEqual(try decoder.decode(FlattenedTypeEncodingAsNestedWithOuterMessageUnkeyed.self, from: input), output)
    }
}
